Project Path: /home/ellyse/projects/langchaindemo

Source Tree:

```
langchaindemo
├── README.md
├── shell.nix
├── mix.exs
├── lib
│   ├── langchaindemo
│   │   ├── user_server.ex
│   │   ├── bot
│   │   │   └── consumer.ex
│   │   ├── process_registry.ex
│   │   ├── util.ex
│   │   ├── user_supervisor.ex
│   │   └── application.ex
│   └── langchaindemo.ex
├── TODO.md
├── test
│   ├── util_test.exs
│   ├── test_helper.exs
│   └── langchaindemo_test.exs
├── mix.lock
└── config
    └── runtime.exs

```

`/home/ellyse/projects/langchaindemo/README.md`:

```````md
# Langchaindemo

**TODO: Add description**

## Installation

Set environment variables for:
* LLM_BOT_TOKEN - discord bot token
* OPENROUTER_API_KEY - key from openrouter.ai

Make sure the Discord bot has gateway intents enabled

If [available in Hex](https://hex.pm/docs/publish), the package can be installed
by adding `langchaindemo` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:langchaindemo, "~> 0.1.0"}
  ]
end
```

Documentation can be generated with [ExDoc](https://github.com/elixir-lang/ex_doc)
and published on [HexDocs](https://hexdocs.pm). Once published, the docs can
be found at <https://hexdocs.pm/langchaindemo>.


```````

`/home/ellyse/projects/langchaindemo/shell.nix`:

```````nix
{
  pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/26d499fc9f1d567283d5d56fcf367edd815dba1d.tar.gz") { config = {}; overlays = []; } }:
let
  _unstable = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/02032da4af073d0f6110540c8677f16d4be0117f.tar.gz") {};
in
pkgs.mkShellNoCC {
  packages = with pkgs; [
    elixir_1_18
    elixir-ls
    marksman # lsp for markdown
    mise # nix needs this to work with elixir-ls and hx for some reason
    mdcat # cat for markdown
  ] ++ [
#    (_unstable.deno)
  ];
}

```````

`/home/ellyse/projects/langchaindemo/mix.exs`:

```````exs
defmodule Langchaindemo.MixProject do
  use Mix.Project

  def project do
    [
      app: :langchaindemo,
      version: "0.1.0",
      elixir: "~> 1.18",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications.
  def application do
    [
      extra_applications: [:logger],
      mod: {Langchaindemo.Application, []}
    ]
  end

  # Run "mix help deps" to learn about dependencies.
  defp deps do
    [
      {:langchain, "~> 0.3.0"},
      {:kino, "~> 0.12.0"},
      {:nostrum, "~> 0.10"},
      {:dialyxir, "~> 1.4", only: [:dev, :test], runtime: false}
    ]
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/user_server.ex`:

```````ex
defmodule Langchaindemo.UserServer do
  use GenServer
  require Logger

  defstruct [:chain, :user_id]

  def start_link(user_id) when is_integer(user_id) do
    Logger.debug("UserServer.start_link: user_id=#{user_id}")

    GenServer.start_link(
      __MODULE__,
      user_id,
      name: via_tuple(user_id)
    )
  end

  @spec run_prompt(non_neg_integer(), String.t()) :: String.t()
  def run_prompt(user_id, prompt) do
    GenServer.call(via_tuple(user_id), {:run_prompt, prompt})
  end

  # Callbacks
  @impl true
  def init(user_id) when is_integer(user_id) do
    Logger.debug("UserServer.init: user_id=#{user_id}")
    chain = Langchaindemo.new_chain()
    {:ok, %__MODULE__{chain: chain, user_id: user_id}}
  end

  # @impl true
  # def handle_cast({:put, key, value}, state) do
  #   {:noreply, Map.put(state, key, value)}
  # end

  @impl true
  def handle_call({:run_prompt, prompt}, _, %__MODULE__{user_id: user_id, chain: chain} = state) do
    Logger.debug("UserServer.handle_call: user_id=#{user_id} running prompt #{prompt}")

    case Langchaindemo.run_user_prompt(chain, prompt) do
      {:ok, new_chain} ->
        # update state
        new_state = %{state | chain: new_chain}

        # pull out the actual text response
        response_text = Langchaindemo.get_last_message(new_chain)

        Logger.debug("UserServer.handle_call: user_id=#{user_id}, response=#{response_text}")

        {:reply, response_text, new_state}

      {:error, _, reason} ->
        Logger.error("UserServer: user_id=#{user_id}, error=#{inspect(reason)}")
        {:reply, "There was an error", state}
    end
  end

  defp via_tuple(user_id) do
    Langchaindemo.ProcessRegistry.via_tuple({__MODULE__, user_id})
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/bot/consumer.ex`:

```````ex
defmodule Langchaindemo.Bot.Consumer do
  use Nostrum.Consumer
  require Logger

  alias Nostrum.Api.Message
  alias Langchaindemo.Util

  @discord_max_msg_length 1700

  # TODO: actually should be recusive when we split because it might be more than double the max size  
  def handle_event(
        {:MESSAGE_CREATE,
         %Nostrum.Struct.Message{
           content: "!llm " <> llm_prompt,
           channel_id: channel_id,
           author: %Nostrum.Struct.User{id: user_id, bot: nil}
         } = _msg, _ws_state}
      ) do
    Logger.debug("Consumer: userid #{user_id}, prompt=#{llm_prompt}")

    # ensure we have a UserServer running for this user
    _pid = Langchaindemo.UserSupervisor.server_process(user_id)

    response =
      Langchaindemo.UserServer.run_prompt(user_id, llm_prompt)
      |> Util.split_len(@discord_max_msg_length)
      |> Enum.each(fn llm_msg when is_binary(llm_msg) ->
        {:ok, _msg} = Message.create(channel_id, llm_msg)
      end)

    Logger.debug("userid #{user_id} llm response=#{response}")
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/process_registry.ex`:

```````ex
defmodule Langchaindemo.ProcessRegistry do
  def start_link do
    Registry.start_link(keys: :unique, name: __MODULE__)
  end

  def via_tuple(key) do
    {:via, Registry, {__MODULE__, key}}
  end

  def child_spec(_) do
    Supervisor.child_spec(
      Registry,
      id: __MODULE__,
      start: {__MODULE__, :start_link, []}
    )
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/util.ex`:

```````ex
defmodule Langchaindemo.Util do
  @doc """
  splits a string into a list of strings, each one of len length, last one length <= len
  """
  @spec split_len(binary(), integer()) :: [binary()]
  def split_len(s, len) when is_binary(s) and is_integer(len) and len > 0 do
    l = String.length(s)

    cond do
      l == 0 ->
        []

      l <= len ->
        [s]

      true ->
        {head, tail} = String.split_at(s, len)
        [head | split_len(tail, len)]
    end
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/user_supervisor.ex`:

```````ex
defmodule Langchaindemo.UserSupervisor do
  use DynamicSupervisor
  require Logger

  def start_link(_) do
    Logger.debug("starting UserSupervisor")

    DynamicSupervisor.start_link(
      name: __MODULE__,
      strategy: :one_for_one
    )
  end

  @impl true
  def init(_init_arg) do
    DynamicSupervisor.init(strategy: :one_for_one)
  end

  @spec server_process(non_neg_integer()) :: pid()
  def server_process(user_id) when is_integer(user_id) do
    case start_child(user_id) do
      {:ok, pid} -> pid
      {:error, {:already_started, pid}} -> pid
    end
  end

  @spec start_child(non_neg_integer()) :: DynamicSupervisor.on_start_child()
  defp start_child(user_id) when is_integer(user_id) do
    DynamicSupervisor.start_child(
      __MODULE__,
      {Langchaindemo.UserServer, user_id}
    )
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo/application.ex`:

```````ex
defmodule Langchaindemo.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      Langchaindemo.Bot.Consumer,
      Langchaindemo.UserSupervisor,
      Langchaindemo.ProcessRegistry
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: Langchaindemo.Supervisor]

    Supervisor.start_link(children, opts)
  end
end

```````

`/home/ellyse/projects/langchaindemo/lib/langchaindemo.ex`:

```````ex
defmodule Langchaindemo do
  alias LangChain.Chains.LLMChain
  alias LangChain.ChatModels.ChatOpenAI
  alias LangChain.Message

  def model(), do: Application.fetch_env!(:langchain, :model)
  def endpoint(), do: Application.fetch_env!(:langchain, :endpoint)
  def system_prompt(), do: Application.fetch_env!(:langchain, :system_prompt)

  def new_chain() do
    %{
      llm:
        ChatOpenAI.new!(%{
          endpoint: endpoint(),
          model: model()
        })
    }
    |> LLMChain.new!()
    |> LLMChain.add_message(Message.new_system!(system_prompt()))
  end

  @spec run_user_prompt(LLMChain.t(), String.t()) ::
          {:ok, LLMChain.t()} | {:error, LLMChain.t(), LangChain.LangChainError.t()}
  def run_user_prompt(%LLMChain{} = chain, prompt) when is_binary(prompt) do
    chain
    |> LLMChain.add_message(Message.new_user!(prompt))
    |> LLMChain.run()
  end

  @spec get_last_message(LLMChain.t()) :: String.t()
  def get_last_message(%LLMChain{} = chain) do
    chain.last_message.content
  end

  def doit(llm_prompt) when is_binary(llm_prompt) do
    {:ok, updated_chain} =
      %{
        llm:
          ChatOpenAI.new!(%{
            endpoint: endpoint(),
            model: model()
          })
      }
      |> LLMChain.new!()
      |> LLMChain.add_messages([
        Message.new_system!(system_prompt()),
        Message.new_user!(llm_prompt)
      ])
      |> LLMChain.run()

    updated_chain.last_message.content
  end
end

```````

`/home/ellyse/projects/langchaindemo/TODO.md`:

```````md
## TODO
* instead of !llm use @botname to call the llm
* make the bot responses replies
* response should be embed if it wants to share images and stuff... make a function for this
* summarize user context when it gets too large
* store summary in a db
* some way to share information? like share my info with corey?
* export into teams, slack, signal, telegram:w

## DONE
* add dialyzer
* truncate longer responses to 2k characters or send as two messages
* change system prompt to be more general
* need to keep user context

```````

`/home/ellyse/projects/langchaindemo/test/util_test.exs`:

```````exs
defmodule UtilTest do
  use ExUnit.Case

  alias Langchaindemo.Util

  describe "split_len/2" do
    test "returns empty list when input string is empty" do
      assert Util.split_len("", 5) == []
    end

    test "returns list with one element when string is shorter than len" do
      assert Util.split_len("abc", 5) == ["abc"]
    end

    test "returns list with one element when string is exactly len" do
      assert Util.split_len("abcde", 5) == ["abcde"]
    end

    test "splits string into equal chunks" do
      assert Util.split_len("abcdefghij", 2) == ["ab", "cd", "ef", "gh", "ij"]
    end

    test "last chunk is shorter when string length is not divisible by len" do
      assert Util.split_len("abcdefghijk", 4) == ["abcd", "efgh", "ijk"]
    end

    test "handles single character chunks" do
      assert Util.split_len("abc", 1) == ["a", "b", "c"]
    end

    test "raises if len is zero or negative" do
      assert_raise FunctionClauseError, fn -> Util.split_len("abc", 0) end
      assert_raise FunctionClauseError, fn -> Util.split_len("abc", -1) end
    end
  end
end

```````

`/home/ellyse/projects/langchaindemo/test/test_helper.exs`:

```````exs
ExUnit.start()

```````

`/home/ellyse/projects/langchaindemo/test/langchaindemo_test.exs`:

```````exs
defmodule LangChainDemoTest do
  use ExUnit.Case
  # doctest LangChainDemo

  # test "greets the world" do
  #   assert Langchaindemo.hello() == :world
  # end
end

```````

`/home/ellyse/projects/langchaindemo/mix.lock`:

```````lock
%{
  "castle": {:hex, :castle, "0.3.1", "e5d4f20696d878052a23c13158e1d372b24d9b30a6ea6f52fa6063c21c5ad67e", [:mix], [{:forecastle, "~> 0.1.3", [hex: :forecastle, repo: "hexpm", optional: false]}], "hexpm", "3ee9ca04b069280ab4197fe753562958729c83b3aa08125255116a989e133835"},
  "certifi": {:hex, :certifi, "2.14.0", "ed3bef654e69cde5e6c022df8070a579a79e8ba2368a00acf3d75b82d9aceeed", [:rebar3], [], "hexpm", "ea59d87ef89da429b8e905264fdec3419f84f2215bb3d81e07a18aac919026c3"},
  "cowlib": {:hex, :cowlib, "2.15.0", "3c97a318a933962d1c12b96ab7c1d728267d2c523c25a5b57b0f93392b6e9e25", [:make, :rebar3], [], "hexpm", "4f00c879a64b4fe7c8fcb42a4281925e9ffdb928820b03c3ad325a617e857532"},
  "decimal": {:hex, :decimal, "2.3.0", "3ad6255aa77b4a3c4f818171b12d237500e63525c2fd056699967a3e7ea20f62", [:mix], [], "hexpm", "a4d66355cb29cb47c3cf30e71329e58361cfcb37c34235ef3bf1d7bf3773aeac"},
  "dialyxir": {:hex, :dialyxir, "1.4.5", "ca1571ac18e0f88d4ab245f0b60fa31ff1b12cbae2b11bd25d207f865e8ae78a", [:mix], [{:erlex, ">= 0.2.7", [hex: :erlex, repo: "hexpm", optional: false]}], "hexpm", "b0fb08bb8107c750db5c0b324fa2df5ceaa0f9307690ee3c1f6ba5b9eb5d35c3"},
  "ecto": {:hex, :ecto, "3.12.5", "4a312960ce612e17337e7cefcf9be45b95a3be6b36b6f94dfb3d8c361d631866", [:mix], [{:decimal, "~> 2.0", [hex: :decimal, repo: "hexpm", optional: false]}, {:jason, "~> 1.0", [hex: :jason, repo: "hexpm", optional: true]}, {:telemetry, "~> 0.4 or ~> 1.0", [hex: :telemetry, repo: "hexpm", optional: false]}], "hexpm", "6eb18e80bef8bb57e17f5a7f068a1719fbda384d40fc37acb8eb8aeca493b6ea"},
  "erlex": {:hex, :erlex, "0.2.7", "810e8725f96ab74d17aac676e748627a07bc87eb950d2b83acd29dc047a30595", [:mix], [], "hexpm", "3ed95f79d1a844c3f6bf0cea61e0d5612a42ce56da9c03f01df538685365efb0"},
  "expo": {:hex, :expo, "1.1.0", "f7b9ed7fb5745ebe1eeedf3d6f29226c5dd52897ac67c0f8af62a07e661e5c75", [:mix], [], "hexpm", "fbadf93f4700fb44c331362177bdca9eeb8097e8b0ef525c9cc501cb9917c960"},
  "finch": {:hex, :finch, "0.19.0", "c644641491ea854fc5c1bbaef36bfc764e3f08e7185e1f084e35e0672241b76d", [:mix], [{:mime, "~> 1.0 or ~> 2.0", [hex: :mime, repo: "hexpm", optional: false]}, {:mint, "~> 1.6.2 or ~> 1.7", [hex: :mint, repo: "hexpm", optional: false]}, {:nimble_options, "~> 0.4 or ~> 1.0", [hex: :nimble_options, repo: "hexpm", optional: false]}, {:nimble_pool, "~> 1.1", [hex: :nimble_pool, repo: "hexpm", optional: false]}, {:telemetry, "~> 0.4 or ~> 1.0", [hex: :telemetry, repo: "hexpm", optional: false]}], "hexpm", "fc5324ce209125d1e2fa0fcd2634601c52a787aff1cd33ee833664a5af4ea2b6"},
  "forecastle": {:hex, :forecastle, "0.1.3", "b07d217ef10799e6d6cc7e47407858e77b1a8cb248f15185534de3403de3aa42", [:mix], [], "hexpm", "07e1ffa79c56f3e0ead59f17c0163a747dafc210ca8f244a7e65a4bfa98dc96d"},
  "fss": {:hex, :fss, "0.1.1", "9db2344dbbb5d555ce442ac7c2f82dd975b605b50d169314a20f08ed21e08642", [:mix], [], "hexpm", "78ad5955c7919c3764065b21144913df7515d52e228c09427a004afe9c1a16b0"},
  "gettext": {:hex, :gettext, "0.26.2", "5978aa7b21fada6deabf1f6341ddba50bc69c999e812211903b169799208f2a8", [:mix], [{:expo, "~> 0.5.1 or ~> 1.0", [hex: :expo, repo: "hexpm", optional: false]}], "hexpm", "aa978504bcf76511efdc22d580ba08e2279caab1066b76bb9aa81c4a1e0a32a5"},
  "gun": {:hex, :gun, "2.2.0", "b8f6b7d417e277d4c2b0dc3c07dfdf892447b087f1cc1caff9c0f556b884e33d", [:make, :rebar3], [{:cowlib, ">= 2.15.0 and < 3.0.0", [hex: :cowlib, repo: "hexpm", optional: false]}], "hexpm", "76022700c64287feb4df93a1795cff6741b83fb37415c40c34c38d2a4645261a"},
  "hpax": {:hex, :hpax, "1.0.3", "ed67ef51ad4df91e75cc6a1494f851850c0bd98ebc0be6e81b026e765ee535aa", [:mix], [], "hexpm", "8eab6e1cfa8d5918c2ce4ba43588e894af35dbd8e91e6e55c817bca5847df34a"},
  "jason": {:hex, :jason, "1.4.4", "b9226785a9aa77b6857ca22832cffa5d5011a667207eb2a0ad56adb5db443b8a", [:mix], [{:decimal, "~> 1.0 or ~> 2.0", [hex: :decimal, repo: "hexpm", optional: true]}], "hexpm", "c5eb0cab91f094599f94d55bc63409236a8ec69a21a67814529e8d5f6cc90b3b"},
  "kino": {:hex, :kino, "0.12.3", "a5f48a243c60a7ac18ba23869f697b1c775fc7794e8cd55dd248ba33c6fe9445", [:mix], [{:fss, "~> 0.1.0", [hex: :fss, repo: "hexpm", optional: false]}, {:nx, "~> 0.1", [hex: :nx, repo: "hexpm", optional: true]}, {:table, "~> 0.1.2", [hex: :table, repo: "hexpm", optional: false]}], "hexpm", "a6dfa3d54ba0edec9ca6e5940154916b381901001f171c85a2d8c67869dbc2d8"},
  "langchain": {:hex, :langchain, "0.3.2", "60117628038cd972707c850e35243aa5afcee214bb91214dca5fb20589edd106", [:mix], [{:abacus, "~> 2.1.0", [hex: :abacus, repo: "hexpm", optional: true]}, {:ecto, "~> 3.10", [hex: :ecto, repo: "hexpm", optional: false]}, {:gettext, "~> 0.20", [hex: :gettext, repo: "hexpm", optional: false]}, {:nimble_parsec, "~> 1.4", [hex: :nimble_parsec, repo: "hexpm", optional: true]}, {:nx, ">= 0.7.0", [hex: :nx, repo: "hexpm", optional: true]}, {:req, ">= 0.5.2", [hex: :req, repo: "hexpm", optional: false]}], "hexpm", "29382c8a241289d1f5723b90d3d8002f51480c12d2265d001e1e0891fb534c55"},
  "mime": {:hex, :mime, "2.0.6", "8f18486773d9b15f95f4f4f1e39b710045fa1de891fada4516559967276e4dc2", [:mix], [], "hexpm", "c9945363a6b26d747389aac3643f8e0e09d30499a138ad64fe8fd1d13d9b153e"},
  "mint": {:hex, :mint, "1.7.1", "113fdb2b2f3b59e47c7955971854641c61f378549d73e829e1768de90fc1abf1", [:mix], [{:castore, "~> 0.1.0 or ~> 1.0", [hex: :castore, repo: "hexpm", optional: true]}, {:hpax, "~> 0.1.1 or ~> 0.2.0 or ~> 1.0", [hex: :hpax, repo: "hexpm", optional: false]}], "hexpm", "fceba0a4d0f24301ddee3024ae116df1c3f4bb7a563a731f45fdfeb9d39a231b"},
  "nimble_options": {:hex, :nimble_options, "1.1.1", "e3a492d54d85fc3fd7c5baf411d9d2852922f66e69476317787a7b2bb000a61b", [:mix], [], "hexpm", "821b2470ca9442c4b6984882fe9bb0389371b8ddec4d45a9504f00a66f650b44"},
  "nimble_pool": {:hex, :nimble_pool, "1.1.0", "bf9c29fbdcba3564a8b800d1eeb5a3c58f36e1e11d7b7fb2e084a643f645f06b", [:mix], [], "hexpm", "af2e4e6b34197db81f7aad230c1118eac993acc0dae6bc83bac0126d4ae0813a"},
  "nostrum": {:hex, :nostrum, "0.10.4", "a316d08b19104f34c5fd5aa56674907350899a5f0c2483afdf5586296bd0ce07", [:mix], [{:castle, "~> 0.3.0", [hex: :castle, repo: "hexpm", optional: false]}, {:certifi, "~> 2.13", [hex: :certifi, repo: "hexpm", optional: false]}, {:ezstd, "~> 1.1", [hex: :ezstd, repo: "hexpm", optional: true]}, {:gun, "~> 2.0", [hex: :gun, repo: "hexpm", optional: false]}, {:jason, "~> 1.4", [hex: :jason, repo: "hexpm", optional: false]}, {:mime, "~> 1.6 or ~> 2.0", [hex: :mime, repo: "hexpm", optional: false]}], "hexpm", "fcc2642bf5b09792865ec2c26c1a11c6aa5432bc623a65dd81141e1eab9f1b99"},
  "req": {:hex, :req, "0.5.10", "a3a063eab8b7510785a467f03d30a8d95f66f5c3d9495be3474b61459c54376c", [:mix], [{:brotli, "~> 0.3.1", [hex: :brotli, repo: "hexpm", optional: true]}, {:ezstd, "~> 1.0", [hex: :ezstd, repo: "hexpm", optional: true]}, {:finch, "~> 0.17", [hex: :finch, repo: "hexpm", optional: false]}, {:jason, "~> 1.0", [hex: :jason, repo: "hexpm", optional: false]}, {:mime, "~> 2.0.6 or ~> 2.1", [hex: :mime, repo: "hexpm", optional: false]}, {:nimble_csv, "~> 1.0", [hex: :nimble_csv, repo: "hexpm", optional: true]}, {:plug, "~> 1.0", [hex: :plug, repo: "hexpm", optional: true]}], "hexpm", "8a604815743f8a2d3b5de0659fa3137fa4b1cffd636ecb69b30b2b9b2c2559be"},
  "table": {:hex, :table, "0.1.2", "87ad1125f5b70c5dea0307aa633194083eb5182ec537efc94e96af08937e14a8", [:mix], [], "hexpm", "7e99bc7efef806315c7e65640724bf165c3061cdc5d854060f74468367065029"},
  "telemetry": {:hex, :telemetry, "1.3.0", "fedebbae410d715cf8e7062c96a1ef32ec22e764197f70cda73d82778d61e7a2", [:rebar3], [], "hexpm", "7015fc8919dbe63764f4b4b87a95b7c0996bd539e0d499be6ec9d7f3875b79e6"},
}

```````

`/home/ellyse/projects/langchaindemo/config/runtime.exs`:

```````exs
import Config

config :langchain,
  openai_key: System.fetch_env!("OPENROUTER_API_KEY"),
  endpoint: "https://openrouter.ai/api/v1/chat/completions",
  model: "meta-llama/llama-4-scout:free",
  system_prompt: """
  You are Ellememe, a language model based on LLaMA 4 Scout, accessible through a Discord bot interface. Keep your responses concise—aim for a couple of paragraphs max—to match Discord’s fast-paced conversational style. Maintain a relaxed, friendly tone. Occasional emoji use is fine if it fits the vibe.
  If the user’s message is unclear or incomplete, ask clarifying questions before answering. Your top priority is the user: adapt your responses to their intent, and strive to be as helpful, accurate, and relevant as possible in every exchange.
  You can be playfully witty when the tone invites it—but don’t force jokes if they don’t land.
  Behavioral constraints:
    * Do not make up facts—if you’re uncertain, say so or suggest where to check.
    * Avoid excessive apologizing or hedging (e.g., “As an AI…”).
    * Don’t give legal, medical, or financial advice.
    * Be concise and avoid over-explaining.
    * Stay neutral in sensitive discussions (e.g., politics, religion) unless the user clearly invites engagement.
  """

config :nostrum,
  token: System.fetch_env!("LLM_BOT_TOKEN"),
  gateway_intents: :all

```````
